# Decisions Log

- D-0001: Routing + data decisions for /pitch/[id] and /pitch/new
  - We implement SSR for `/pitch/[id]` using Supabase anon client (RLS enforced).
  - Reads: `pitches` table filtered by `is_active = true` and `plan_expires_at > now()`.
  - Related tables expected by spec: `endorsements`, `resume_requests`, `referral_links`, `referral_events`, `activity_log`.
  - Mutations are designed to be RLS-safe. If policies/tables are missing, migrations are required before actions will succeed.
  - Likes: we use an insert into `pitch_likes` (or a stored procedure `increment_likes(pitch_id uuid)` if available). If neither exists, create one of these server-side utilities.
  - `/pitch/new` uses OpenAI (title ≤ 80, pitch ≤ 300, exactly 3 skills) and Razorpay. Webhook activates plan by setting `plan_tier` and computing `plan_expires_at`.
  - Until service keys are provided, all operations rely on anon-key and RLS policies.

- D-0002: Resume approval behavior aligned to spec
  - **Date**: 2025-01-06
  - **Context**: Resume request approval flow needs to match spec requirements
  - **Decision**: 
    - Only auto-send resume if veteran has uploaded file AND opted-in to share (`resume_share_enabled`)
    - Use pre-signed Supabase Storage URLs (24h expiry) for secure access
    - HMAC-signed tokens for approve/decline actions with replay protection
    - Set `responded_at` timestamp to prevent duplicate responses
  - **Consequences**: 
    - More secure and privacy-respecting
    - Requires token generation/verification infrastructure
    - Pre-signed URLs provide time-limited access without exposing storage credentials

- D-0003: Referral debounce key strategy
  - **Date**: 2025-01-06
  - **Context**: Need to prevent duplicate referral events from rapid interactions
  - **Decision**: 
    - Use SHA-256 hash of (referralId + eventType + ipHash) as debounce key
    - 10-minute debounce window for same event type per referral
    - Store debounce_key in referral_events table for efficient lookups
  - **Consequences**: 
    - Prevents spam from page refreshes and rapid clicks
    - Maintains data integrity while allowing legitimate repeated events after timeout

- D-0004: IP hashing method for privacy
  - **Date**: 2025-01-06
  - **Context**: Need to track referral events while protecting user privacy
  - **Decision**: 
    - Hash IP addresses with SHA-256 + salt before storage
    - Use environment variable IP_HASH_SALT for additional security
    - Never store raw IP addresses in database
  - **Consequences**: 
    - Enables fraud detection while maintaining GDPR compliance
    - Salt prevents rainbow table attacks on hashed IPs

- D-0005: AI guardrails prompt
  - **Date**: 2025-01-06
  - **Context**: Need to ensure AI-generated pitches meet quality and length constraints
  - **Decision**: 
    - Use structured system prompt with explicit character limits (title ≤80, pitch ≤300)
    - Enforce exactly 3 skills requirement
    - Server-side validation and truncation as backup
    - Focus on outcomes-first, civilian-relevant content
  - **Consequences**: 
    - Consistent pitch quality and format
    - Prevents AI from generating overly long or inappropriate content
    - Maintains platform standards across all AI-generated pitches

- D-0006: Webhook idempotency strategy
  - **Date**: 2025-01-06
  - **Context**: Razorpay webhooks can be delivered multiple times, need to prevent duplicate processing
  - **Decision**: 
    - Store razorpay_event_id in payment_events table
    - Check for existing event before processing
    - Use upsert for pitch creation to handle edge cases
    - Log all webhook events for audit trail
  - **Consequences**: 
    - Prevents duplicate pitch creation and activity logging
    - Maintains data integrity even with webhook retries
    - Provides audit trail for payment processing

- D-0007: Dashboard architecture
  - **Date**: 2025-01-27
  - **Context**: Need role-based dashboards with RLS enforcement
  - **Decision**: 
    - Server components for data fetch, client components for interactivity
    - Role-based routing with authentication checks
    - RLS-enforced metrics queries for data security
    - Responsive grid layout (1-col mobile, 2-col desktop)
  - **Consequences**: 
    - Maintains security through RLS policies
    - Provides good UX with role-specific widgets
    - Follows Next.js best practices for performance

- D-0008: CRON job approach
  - **Date**: 2025-01-27
  - **Context**: Need to expire plans automatically
  - **Decision**: 
    - API route with API key authentication
    - Can be called by external CRON service (Vercel, GitHub Actions, etc.)
    - Logs activity events for expired pitches
    - Supports both GET and POST for flexibility
  - **Consequences**: 
    - Simple and secure implementation
    - Works with any hosting platform
    - Provides audit trail for plan expirations

- D-0009: SEO strategy
  - **Date**: 2025-01-27
  - **Context**: Need comprehensive SEO for pitch pages and main sections
  - **Decision**: 
    - Dynamic sitemap with active pitches only
    - next-seo integration with role-based SEO functions
    - OG tags for pitch details with photo support
    - Security headers for sensitive routes
  - **Consequences**: 
    - Maximizes discoverability of veteran profiles
    - Follows SEO best practices
    - Enhances social media sharing

- D-0010: Security headers final
  - **Date**: 2025-01-27
  - **Context**: Production security hardening requirements
  - **Decision**: 
    - X-Content-Type-Options: nosniff
    - X-Frame-Options: DENY (frame-ancestors 'none' for sensitive routes)
    - X-XSS-Protection: 1; mode=block
    - Referrer-Policy: strict-origin-when-cross-origin
    - CSP headers for dashboard and API routes
  - **Consequences**: 
    - Prevents clickjacking and XSS attacks
    - Protects sensitive routes from being embedded
    - Follows OWASP security guidelines

- D-0011: Rate limit scope
  - **Date**: 2025-01-27
  - **Context**: Need to prevent abuse of sensitive endpoints
  - **Decision**: 
    - Webhook: 10 requests/minute
    - Resume requests: 5 requests/minute
    - Referral events: 20 requests/minute
    - General API: 100 requests/minute
    - In-memory storage for dev, Redis for production
  - **Consequences**: 
    - Prevents abuse while allowing legitimate usage
    - Simple implementation for development
    - Scalable for production deployment

- D-0012: Lighthouse outcome and major fixes
  - **Date**: 2025-01-27
  - **Context**: Performance and accessibility requirements
  - **Decision**: 
    - Performance ≥ 90, Accessibility ≥ 95, SEO ≥ 90
    - Automated testing with Puppeteer
    - Focus on mobile performance
    - Image optimization and lazy loading
    - Critical CSS inlining
  - **Consequences**: 
    - Ensures good user experience
    - Meets modern web standards
    - Improves search engine rankings

- D-0013: Webhook idempotency test hash
  - **Date**: 2025-01-27
  - **Context**: Need to verify webhook idempotency in testing
  - **Decision**: 
    - Use event_id as unique constraint
    - Test with duplicate event IDs
    - Verify no duplicate processing
    - Log all webhook attempts for audit
  - **Consequences**: 
    - Prevents duplicate payment processing
    - Maintains data integrity
    - Provides audit trail for debugging

- D-0014: Automated billing system architecture
  - **Date**: 2025-01-27
  - **Context**: Need comprehensive invoicing and 80G receipt management
  - **Decision**: 
    - Fiscal year computation (April-March cycle)
    - Sequential numbering with concurrency control
    - PDF generation using react-pdf/renderer
    - Secure storage with signed URLs
    - Webhook branching for service vs donation payments
    - RLS enforcement for document access
  - **Consequences**: 
    - Automated invoice/receipt generation
    - Tax compliance for 80G donations
    - Secure document access control
    - Scalable numbering system

- D-0015: Billing system data flow
  - **Date**: 2025-01-27
  - **Context**: Need to define complete billing workflow
  - **Decision**: 
    - Payment event → PDF generation → Storage upload → DB insert → Email dispatch
    - Idempotency via event_id unique constraint
    - Branching based on order.notes.type
    - Signed URLs for secure document access
    - Dashboard integration for user access
  - **Consequences**: 
    - End-to-end automated billing
    - No duplicate document generation
    - Secure document delivery
    - User-friendly access via dashboards
